<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Collections</title>
  <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
  <!-- Header Placeholder -->
  <div id="header-container"></div>

  <main>
    <section>
      <h2>Introduction</h2>
      <p>
        An array is an indexed collection of fixed number of homogeneous data elements. Alternatively, it represents a group of elements of the same data type. 
        The primary advantage of arrays is that we can represent a large number of elements using a single variable, improving code readability.
      </p>

      <h3>Limitations of Arrays</h3>
      <ol style="margin-left: 30px;">
        <li>Arrays are fixed in size. Once created, the size cannot be increased or decreased dynamically.</li>
        <li>Arrays can hold only homogeneous data elements.</li>
        <li>Arrays lack ready-made method support because they are not implemented using any data structure.</li>
      </ol>

      <h3>Examples of Arrays</h3>
      <pre><code>
// Fixed-size array of Students
Student[] s = new Student[10000];
s[0] = new Student();   // Valid
s[1] = new Customer();  // Compile-time error

// Error Output:
Test.java:7: cannot find symbol
Symbol: class Customer
Location: class Test
s[1] = new Customer();
      </code></pre>

      <h3>Using Object Arrays to Address Homogeneity Issue</h3>
      <p>We can use an <code>Object[]</code> array to hold heterogeneous elements:</p>
      <pre><code>
Object[] o = new Object[10000];
o[0] = new Student();    // Valid
o[1] = new Customer();   // Valid
      </code></pre>

      <h2>Introduction to Collections</h2>
      <p>
        Collections in Java overcome the limitations of arrays by being growable in nature and providing support for both homogeneous and heterogeneous data.
        They are implemented based on standard data structures and come with ready-made methods for common operations.
      </p>

      <h3>Advantages of Collections</h3>
      <ol style="margin-left: 30px;">
        <li>Growable: Collections can dynamically increase or decrease in size as per requirements.</li>
        <li>Memory Efficient: More suitable for memory management than arrays.</li>
        <li>Homogeneous and Heterogeneous: Can hold both types of data elements.</li>
        <li>Ready-Made Methods: Collections offer standard methods for operations, simplifying development.</li>
      </ol>

      <h2>Differences Between Arrays and Collections</h2>
      <table border="1" cellpadding="8">
        <thead>
          <tr>
            <th>Feature</th>
            <th>Arrays</th>
            <th>Collections</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Size</td>
            <td>Fixed</td>
            <td>Growable</td>
          </tr>
          <tr>
            <td>Memory Usage</td>
            <td>Not memory-efficient</td>
            <td>Highly memory-efficient</td>
          </tr>
          <tr>
            <td>Performance</td>
            <td>Better performance</td>
            <td>Relatively slower</td>
          </tr>
          <tr>
            <td>Data Type</td>
            <td>Homogeneous only</td>
            <td>Both homogeneous and heterogeneous</td>
          </tr>
          <tr>
            <td>Underlying Data Structure</td>
            <td>None</td>
            <td>Implemented based on standard data structures</td>
          </tr>
          <tr>
            <td>Primitive Type Support</td>
            <td>Supports both primitives and objects</td>
            <td>Supports only objects</td>
          </tr>
        </tbody>
      </table>

      <h2>Conclusion</h2>
      <p>While arrays are more performant and simpler for small, fixed-size homogeneous data, collections are versatile, memory-efficient, and developer-friendly for dynamic and mixed-type data requirements.</p>
    </section>

    <section>
        <h2>Java Collection Framework</h2>
        <p>The Collection Framework in Java provides a standardized way to represent and manipulate groups of objects as a single entity. It offers various classes and interfaces to make working with collections easier and more efficient.</p>
  
        <h3>1. What is a Collection?</h3>
        <p>If we want to represent a group of objects as a single entity, we use a collection. It is a container for storing, managing, and processing objects.</p>
  
        <h3>2. Java Collection Framework</h3>
        <p>The Collection Framework defines several classes and interfaces to represent a group of objects as a single entity. It is analogous to the <strong>STL (Standard Template Library)</strong> in C++.</p>
  
        <table>
          <thead>
            <tr>
              <th>Java</th>
              <th>C++</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Collection</td>
              <td>Containers</td>
            </tr>
            <tr>
              <td>Collection Framework</td>
              <td>STL (Standard Template Library)</td>
            </tr>
          </tbody>
        </table>
  
        <h3>3. Key Interfaces of the Collection Framework</h3>
        <p>The Collection Framework consists of 9 key interfaces that define the structure and behavior of collections in Java:</p>
        <ul>
          <li><strong>Collection</strong>: The root interface for representing a group of objects.</li>
          <li><strong>List</strong>: An ordered collection that allows duplicates (e.g., ArrayList, LinkedList).</li>
          <li><strong>Set</strong>: A collection that does not allow duplicates (e.g., HashSet, LinkedHashSet).</li>
          <li><strong>SortedSet</strong>: A Set that maintains elements in a sorted order (e.g., TreeSet).</li>
          <li><strong>NavigableSet</strong>: A SortedSet with additional navigation methods (e.g., TreeSet).</li>
          <li><strong>Queue</strong>: A collection that operates in a FIFO (First-In-First-Out) manner (e.g., LinkedList, PriorityQueue).</li>
          <li><strong>Map</strong>: A collection for storing key-value pairs (e.g., HashMap, LinkedHashMap).</li>
          <li><strong>SortedMap</strong>: A Map that maintains keys in a sorted order (e.g., TreeMap).</li>
          <li><strong>NavigableMap</strong>: A SortedMap with navigation methods (e.g., TreeMap).</li>
        </ul>
      </section>
      <section>
        <h2>Java Collection Framework</h2>
        <p>The Java Collection Framework provides interfaces and classes to represent and manipulate groups of objects as single entities.</p>
  
        <!-- Collection -->
        <div class="collection-section">
          <h3>1. Collection</h3>
          <p>The <strong>Collection</strong> interface is considered the root interface of the entire collection framework. It defines the most common methods applicable to any collection object.</p>
          <ul>
            <li>If we want to represent a group of "individual objects" as a single entity, we should use a collection.</li>
            <li>No concrete class implements the <code>Collection</code> interface directly.</li>
          </ul>
          <ul>
            <li><strong>Child Interfaces:</strong> List, Set, Queue</li>
          </ul>
        </div>
  
        <!-- List -->
        <div class="collection-section">
          <h3>2. List</h3>
          <p>The <strong>List</strong> interface is a child of the Collection interface. It is used to represent a group of objects where:</p>
          <ul>
            <li>Duplicates are allowed.</li>
            <li>Insertion order is preserved.</li>
          </ul>
          <ul>
            <li><strong>Child Classes:</strong> ArrayList, LinkedList, Vector, Stack</li>
          </ul>
        </div>
  
        <!-- Set -->
        <div class="collection-section">
          <h3>3. Set</h3>
          <p>The <strong>Set</strong> interface is a child of the Collection interface. It is used to represent a group of objects where:</p>
          <ul>
            <li>Duplicates are not allowed.</li>
            <li>Insertion order is not preserved.</li>
          </ul>
          <ul>
            <li><strong>Child Classes:</strong> HashSet, LinkedHashSet</li>
          </ul>
        </div>
  
        <!-- SortedSet -->
        <div class="collection-section">
          <h3>4. SortedSet</h3>
          <p>The <strong>SortedSet</strong> interface is a child of the Set interface. It is used to represent a group of unique objects arranged in a sorted order.</p>
          <ul>
            <li><strong>Child Classes:</strong> TreeSet</li>
          </ul>
        </div>
  
        <!-- NavigableSet -->
        <div class="collection-section">
          <h3>5. NavigableSet</h3>
          <p>The <strong>NavigableSet</strong> interface is a child of the SortedSet interface. It provides several methods for navigation purposes, such as:</p>
          <ul>
            <li><code>lower()</code>, <code>higher()</code></li>
            <li><code>floor()</code>, <code>ceiling()</code></li>
          </ul>
          <ul>
            <li><strong>Child Classes:</strong> TreeSet</li>
          </ul>
        </div>
  
        <!-- Queue -->
        <div class="collection-section">
          <h3>6. Queue</h3>
          <p>The <strong>Queue</strong> interface is a child of the Collection interface. It is used to represent a group of objects prior to processing. The common behavior of a queue is FIFO (First In, First Out).</p>
          <ul>
            <li><strong>Child Classes:</strong> LinkedList, PriorityQueue, ArrayDeque</li>
          </ul>
        </div>

        <div class="collection-section">
            <img src="../img/collections-removebg-preview.png">
        </div>
  
        <!-- Map -->
        <div class="collection-section">
          <h3>7. Map</h3>
          <p>The <strong>Map</strong> interface is used to represent a group of objects as key-value pairs.</p>
          <p>Key points:</p>
          <ul>
            <li>Keys must be unique, but values can be duplicated.</li>
            <li>The Map interface is not a child of the Collection interface.</li>
          </ul>
          <ul>
            <li><strong>Child Classes:</strong> HashMap, LinkedHashMap, Hashtable, TreeMap</li>
          </ul>
        </div>
  
        <!-- SortedMap -->
        <div class="collection-section">
          <h3>8. SortedMap</h3>
          <p>The <strong>SortedMap</strong> interface is a child of the Map interface. It is used to represent a group of key-value pairs sorted by keys.</p>
          <ul>
            <li><strong>Child Classes:</strong> TreeMap</li>
          </ul>
        </div>
  
        <!-- NavigableMap -->
        <div class="collection-section">
          <h3>9. NavigableMap</h3>
          <p>The <strong>NavigableMap</strong> interface is a child of the SortedMap interface. It provides navigation methods, such as:</p>
          <ul>
            <li><code>lowerKey()</code>, <code>higherKey()</code></li>
            <li><code>descendingMap()</code></li>
          </ul>
          <ul>
            <li><strong>Child Classes:</strong> TreeMap</li>
          </ul>
        </div>
        <div class="collection-section">
            <img src="../img/collections-removebg-preview.png">
          </div>
      </section>

      <section>
        <h2>Java Collection Framework: Key Differences</h2>
  
        <!-- Table: Collection vs Map -->
        <h3>1. Differences Between Collection and Map</h3>
        <table border="1" cellpadding="10">
          <thead>
            <tr>
              <th>Aspect</th>
              <th>Collection</th>
              <th>Map</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Definition</td>
              <td>Represents a group of individual objects as a single entity.</td>
              <td>Represents a group of key-value pairs.</td>
            </tr>
            <tr>
              <td>Hierarchy</td>
              <td>Rooted at the <code>Collection</code> interface.</td>
              <td>Not part of the <code>Collection</code> hierarchy.</td>
            </tr>
            <tr>
              <td>Duplicates</td>
              <td>May or may not allow duplicates (depending on implementation).</td>
              <td>Does not allow duplicate keys; values can be duplicated.</td>
            </tr>
            <tr>
              <td>Ordering</td>
              <td>Depends on the specific implementation (e.g., <code>List</code> preserves insertion order).</td>
              <td>Keys can be ordered if using <code>SortedMap</code> or <code>TreeMap</code>.</td>
            </tr>
            <tr>
              <td>Examples</td>
              <td><code>List</code>, <code>Set</code>, <code>Queue</code></td>
              <td><code>HashMap</code>, <code>TreeMap</code>, <code>LinkedHashMap</code></td>
            </tr>
          </tbody>
        </table>
  
        <!-- Table: List vs Set vs Queue -->
        <h3>2. Differences Between List, Set, and Queue</h3>
        <table border="1" cellpadding="10">
          <thead>
            <tr>
              <th>Aspect</th>
              <th>List</th>
              <th>Set</th>
              <th>Queue</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Definition</td>
              <td>Represents a group of objects where duplicates are allowed, and insertion order is preserved.</td>
              <td>Represents a group of unique objects with no duplicates allowed.</td>
              <td>Represents a group of objects arranged in the order of processing.</td>
            </tr>
            <tr>
              <td>Duplicates</td>
              <td>Allowed.</td>
              <td>Not allowed.</td>
              <td>Allowed, depending on the implementation.</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>Insertion order is preserved.</td>
              <td>Order is not preserved (except in <code>LinkedHashSet</code>).</td>
              <td>Order depends on the queue type (e.g., FIFO for <code>Queue</code>, priority order for <code>PriorityQueue</code>).</td>
            </tr>
            <tr>
              <td>Key Methods</td>
              <td><code>add()</code>, <code>get()</code>, <code>remove()</code>, <code>indexOf()</code></td>
              <td><code>add()</code>, <code>remove()</code>, <code>contains()</code></td>
              <td><code>offer()</code>, <code>poll()</code>, <code>peek()</code></td>
            </tr>
            <tr>
              <td>Examples</td>
              <td><code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>, <code>Stack</code></td>
              <td><code>HashSet</code>, <code>LinkedHashSet</code>, <code>TreeSet</code></td>
              <td><code>LinkedList</code>, <code>PriorityQueue</code>, <code>ArrayDeque</code></td>
            </tr>
          </tbody>
        </table>
      </section>

      <section>
        <h2>List Implementations in Java</h2>
        <p>The Java <code>List</code> interface represents an ordered collection (also known as a sequence). It allows duplicate elements and provides methods to access elements by their position in the list. Below are descriptions of key list implementations in Java:</p>
  
        <h3>1. ArrayList</h3>
        <p>The <strong>ArrayList</strong> class uses a dynamic array to store the elements. It is part of the <code>java.util</code> package and implements the <code>List</code> interface. It allows duplicates, preserves insertion order, and allows null values.</p>
        <ul>
          <li><strong>Data Structure</strong>: Resizable array.</li>
          <li><strong>Allows Duplicates</strong>: Yes.</li>
          <li><strong>Preserves Insertion Order</strong>: Yes.</li>
          <li><strong>Allows Null Insertion</strong>: Yes.</li>
          <li><strong>Supports Heterogeneous Data</strong>: Yes.</li>
          <li><strong>Best Choice For</strong>: Retrieval operations (due to fast access using index).</li>
          <li><strong>Not Ideal For</strong>: Frequent modifications (insertion and removal in the middle of the list).</li>
        </ul>
  
        <h4>Example: ArrayList</h4>
        <pre><code>
  import java.util.ArrayList;
  
  public class ArrayListExample {
      public static void main(String[] args) {
          ArrayList<String> list = new ArrayList<>();
          list.add("Apple");
          list.add("Banana");
          list.add("Cherry");
  
          // Displaying elements
          for (String fruit : list) {
              System.out.println(fruit);
          }
      }
  }
        </code></pre>
  
        <h3>2. LinkedList</h3>
        <p>The <strong>LinkedList</strong> class uses a doubly linked list to store elements. It implements both the <code>List</code> and <code>Deque</code> interfaces. It allows duplicates, preserves insertion order, and allows null values.</p>
        <ul>
          <li><strong>Data Structure</strong>: Doubly linked list.</li>
          <li><strong>Allows Duplicates</strong>: Yes.</li>
          <li><strong>Preserves Insertion Order</strong>: Yes.</li>
          <li><strong>Allows Null Insertion</strong>: Yes.</li>
          <li><strong>Supports Heterogeneous Data</strong>: Yes.</li>
          <li><strong>Best Choice For</strong>: Frequent modifications (insertion and deletion) as linked lists offer constant time insertions and deletions.</li>
          <li><strong>Not Ideal For</strong>: Frequent retrieval (no fast indexing).</li>
        </ul>
  
        <h4>Example: LinkedList</h4>
        <pre><code>
  import java.util.LinkedList;
  
  public class LinkedListExample {
      public static void main(String[] args) {
          LinkedList<String> list = new LinkedList<>();
          list.add("Apple");
          list.add("Banana");
          list.add("Cherry");
  
          // Displaying elements
          for (String fruit : list) {
              System.out.println(fruit);
          }
      }
  }
        </code></pre>
  
        <h3>3. Vector</h3>
        <p>The <strong>Vector</strong> class is similar to <code>ArrayList</code> but with synchronized methods. It is a legacy class in the <code>java.util</code> package and also implements the <code>List</code> interface. Vectors are thread-safe but tend to have performance issues due to synchronization.</p>
        <ul>
          <li><strong>Data Structure</strong>: Resizable array.</li>
          <li><strong>Allows Duplicates</strong>: Yes.</li>
          <li><strong>Preserves Insertion Order</strong>: Yes.</li>
          <li><strong>Allows Null Insertion</strong>: Yes.</li>
          <li><strong>Supports Heterogeneous Data</strong>: Yes.</li>
          <li><strong>Best Choice For</strong>: Retrieval operations (fast access), but not ideal for frequent modifications due to synchronization overhead.</li>
          <li><strong>Not Ideal For</strong>: Frequent modifications due to lower performance.</li>
        </ul>
  
        <h4>Example: Vector</h4>
        <pre><code>
  import java.util.Vector;
  
  public class VectorExample {
      public static void main(String[] args) {
          Vector<String> vector = new Vector<>();
          vector.add("Apple");
          vector.add("Banana");
          vector.add("Cherry");
  
          // Displaying elements
          for (String fruit : vector) {
              System.out.println(fruit);
          }
      }
  }
        </code></pre>
  
        <h3>4. Stack</h3>
        <p>The <strong>Stack</strong> class represents a last-in, first-out (LIFO) stack of objects. It extends <code>Vector</code> and provides methods like <code>push()</code>, <code>pop()</code>, <code>peek()</code>, and <code>empty()</code> for stack operations. Like <code>Vector</code>, it is synchronized.</p>
        <ul>
          <li><strong>Data Structure</strong>: Stack (LIFO).</li>
          <li><strong>Allows Duplicates</strong>: Yes.</li>
          <li><strong>Preserves Insertion Order</strong>: Yes (but works on LIFO principle).</li>
          <li><strong>Allows Null Insertion</strong>: Yes.</li>
          <li><strong>Supports Heterogeneous Data</strong>: Yes.</li>
          <li><strong>Best Choice For</strong>: Stack operations (LIFO structure).</li>
          <li><strong>Not Ideal For</strong>: Frequent modifications or general use as a list.</li>
        </ul>
  
        <h4>Example: Stack</h4>
        <pre><code>
  import java.util.Stack;
  
  public class StackExample {
      public static void main(String[] args) {
          Stack<String> stack = new Stack<>();
          stack.push("Apple");
          stack.push("Banana");
          stack.push("Cherry");
  
          // Displaying elements using LIFO order
          while (!stack.isEmpty()) {
              System.out.println(stack.pop());
          }
      }
  }
        </code></pre>
  
        <h3>Differences Between List Implementations</h3>
        <h4>Differences Between List Implementations</h4>
      <table border="1">
        <thead>
          <tr>
            <th>Feature</th>
            <th>ArrayList</th>
            <th>Vector</th>
            <th>LinkedList</th>
            <th>Stack</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Data Structure</td>
            <td>Resizable Array</td>
            <td>Resizable Array</td>
            <td>Doubly Linked List</td>
            <td>Stack (LIFO)</td>
          </tr>
          <tr>
            <td>Allows Duplicates</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>Yes</td>
          </tr>
          <tr>
            <td>Insertion Order</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>Yes</td>
          </tr>
          <tr>
            <td>Null Insertion</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>Yes</td>
          </tr>
          <tr>
            <td>Supports Heterogeneous Data</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>Yes</td>
          </tr>
          <tr>
            <td>Best For</td>
            <td>Retrieval Operations</td>
            <td>Retrieval Operations</td>
            <td>Frequent Modifications</td>
            <td>Last-In-First-Out Operations</td>
          </tr>
          <tr>
            <td>Thread-Safety</td>
            <td>No</td>
            <td>Yes (but slower)</td>
            <td>No</td>
            <td>Yes (but slower)</td>
          </tr>
          <tr>
            <td>Legacy Class</td>
            <td>No</td>
            <td>Yes</td>
            <td>No</td>
            <td>Yes</td>
          </tr>
        </tbody>
      </table>
        <h4>Difference Between ArrayList and Vector</h4>
        <table border="1">
          <tr>
            <th>Aspect</th>
            <th>ArrayList</th>
            <th>Vector</th>
          </tr>
          <tr>
            <td>Data Structure</td>
            <td>Resizable array</td>
            <td>Resizable array</td>
          </tr>
          <tr>
            <td>Thread Safety</td>
            <td>Not synchronized</td>
            <td>Synchronized (thread-safe)</td>
          </tr>
          <tr>
            <td>Performance</td>
            <td>Faster for most operations</td>
            <td>Slower due to synchronization overhead</td>
          </tr>
          <tr>
            <td>Growth Factor</td>
            <td>Increases by 50% when full</td>
            <td>Increases by doubling its size when full</td>
          </tr>
        </table>
  
        <h4>Difference Between ArrayList and LinkedList</h4>
        <table border="1">
          <tr>
            <th>Aspect</th>
            <th>ArrayList</th>
            <th>LinkedList</th>
          </tr>
          <tr>
            <td>Data Structure</td>
            <td>Resizable array</td>
            <td>Doubly linked list</td>
          </tr>
          <tr>
            <td>Insertion/Deletion</td>
            <td>Slower (due to shifting elements)</td>
            <td>Faster (due to linked list structure)</td>
          </tr>
          <tr>
            <td>Access Time</td>
            <td>Faster (random access with index)</td>
            <td>Slower (no index-based access)</td>
          </tr>
          <tr>
            <td>Memory Consumption</td>
            <td>Less memory overhead</td>
            <td>More memory overhead due to node pointers</td>
          </tr>
        </table>
  
      </section>
      <section>
        <h2>Set Implementations in Java</h2>
        <p>The Java <code>Set</code> interface represents a collection of unique elements. It does not allow duplicate elements and provides methods for accessing elements, but does not guarantee order. The following are key `Set` implementations in Java:</p>
  
        <h3>1. HashSet</h3>
        <p>The <strong>HashSet</strong> class uses a hash table for storage. It does not allow duplicates, and the insertion order is not preserved. It allows null insertion and supports heterogeneous data types.</p>
        <ul>
          <li><strong>Data Structure</strong>: Hash Table</li>
          <li><strong>Does Not Allow Duplicates</strong>: Yes</li>
          <li><strong>Preserves Insertion Order</strong>: No</li>
          <li><strong>Allows Null Insertion</strong>: Yes</li>
          <li><strong>Supports Heterogeneous Data</strong>: Yes</li>
          <li><strong>Best For</strong>: When the collection needs to ensure uniqueness but the order does not matter.</li>
        </ul>
  
        <h4>Example: HashSet</h4>
        <pre><code>
  import java.util.HashSet;
  
  public class HashSetExample {
      public static void main(String[] args) {
          HashSet<String> set = new HashSet<>();
          set.add("Apple");
          set.add("Banana");
          set.add("Cherry");
  
          // Displaying elements
          for (String fruit : set) {
              System.out.println(fruit);
          }
      }
  }
        </code></pre>
  
        <h3>2. LinkedHashSet</h3>
        <p>The <strong>LinkedHashSet</strong> class is similar to <code>HashSet</code>, but it also maintains a doubly linked list of elements to preserve the insertion order. It does not allow duplicates and allows null insertion, and it supports heterogeneous data types.</p>
        <ul>
          <li><strong>Data Structure</strong>: Hash Table + Doubly Linked List</li>
          <li><strong>Does Not Allow Duplicates</strong>: Yes</li>
          <li><strong>Preserves Insertion Order</strong>: Yes</li>
          <li><strong>Allows Null Insertion</strong>: Yes</li>
          <li><strong>Supports Heterogeneous Data</strong>: Yes</li>
          <li><strong>Best For</strong>: When the collection needs to ensure uniqueness and preserve insertion order.</li>
        </ul>
  
        <h4>Example: LinkedHashSet</h4>
        <pre><code>
  import java.util.LinkedHashSet;
  
  public class LinkedHashSetExample {
      public static void main(String[] args) {
          LinkedHashSet<String> set = new LinkedHashSet<>();
          set.add("Apple");
          set.add("Banana");
          set.add("Cherry");
  
          // Displaying elements
          for (String fruit : set) {
              System.out.println(fruit);
          }
      }
  }
        </code></pre>
  
        <h3>3. TreeSet</h3>
        <p>The <strong>TreeSet</strong> class implements the <code>Set</code> interface using a balanced tree. It does not allow duplicates and preserves elements according to a natural order or a custom comparator. However, it does not allow null insertion and supports only homogeneous data types (all elements must be of the same type).</p>
        <ul>
          <li><strong>Data Structure</strong>: Balanced Tree</li>
          <li><strong>Does Not Allow Duplicates</strong>: Yes</li>
          <li><strong>Preserves Insertion Order</strong>: No (preserves sorting order)</li>
          <li><strong>Allows Null Insertion</strong>: No</li>
          <li><strong>Supports Heterogeneous Data</strong>: No</li>
          <li><strong>Best For</strong>: When elements need to be sorted and uniqueness is required.</li>
        </ul>
  
        <h4>Example: TreeSet</h4>
        <pre><code>
  import java.util.TreeSet;
  
  public class TreeSetExample {
      public static void main(String[] args) {
          TreeSet<String> set = new TreeSet<>();
          set.add("Apple");
          set.add("Banana");
          set.add("Cherry");
  
          // Displaying elements
          for (String fruit : set) {
              System.out.println(fruit);
          }
      }
  }
        </code></pre>
  
        <h3>Differences Between Set Implementations</h3>
        <h4>Difference Between HashSet, LinkedHashSet, and TreeSet</h4>
        <table border="1">
          <tr>
            <th>Aspect</th>
            <th>HashSet</th>
            <th>LinkedHashSet</th>
            <th>TreeSet</th>
          </tr>
          <tr>
            <td>Data Structure</td>
            <td>Hash Table</td>
            <td>Hash Table + Doubly Linked List</td>
            <td>Balanced Tree</td>
          </tr>
          <tr>
            <td>Duplicates</td>
            <td>Does not allow duplicates</td>
            <td>Does not allow duplicates</td>
            <td>Does not allow duplicates</td>
          </tr>
          <tr>
            <td>Insertion Order</td>
            <td>Not preserved</td>
            <td>Preserved</td>
            <td>Not preserved (sorted order)</td>
          </tr>
          <tr>
            <td>Null Insertion</td>
            <td>Allowed</td>
            <td>Allowed</td>
            <td>Not allowed</td>
          </tr>
          <tr>
            <td>Supports Heterogeneous Data</td>
            <td>Yes</td>
            <td>Yes</td>
            <td>No (Homogeneous data only)</td>
          </tr>
          <tr>
            <td>Sorting Order</td>
            <td>Not sorted</td>
            <td>Not sorted</td>
            <td>Sorted by natural order or custom comparator</td>
          </tr>
          <tr>
            <td>Best For</td>
            <td>When insertion order doesn't matter and fast operations are required</td>
            <td>When insertion order needs to be preserved</td>
            <td>When sorted order is required for elements</td>
          </tr>
        </table>
  
      </section>
  
      <section>
        <h2>Queue Implementations in Java</h2>
        <p>The <code>Queue</code> interface in Java represents a collection designed for holding elements prior to processing. It follows the First-In-First-Out (FIFO) principle. Here are some key queue implementations in Java:</p>
  
        <h3>1. Queue</h3>
        <p>The <strong>Queue</strong> interface represents a collection of elements, where elements are processed in a FIFO order. It is part of the <code>java.util</code> package and provides methods such as <code>offer()</code>, <code>poll()</code>, and <code>peek()</code>.</p>
        <ul>
          <li><strong>Data Structure</strong>: FIFO (First-In-First-Out)</li>
          <li><strong>Allows Duplicates</strong>: Yes</li>
          <li><strong>Preserves Insertion Order</strong>: Yes</li>
          <li><strong>Null Insertion</strong>: Yes (depends on the specific implementation)</li>
          <li><strong>Best For</strong>: When elements need to be processed in the order they were added.</li>
        </ul>
  
        <h3>2. PriorityQueue</h3>
        <p>The <strong>PriorityQueue</strong> class implements the <code>Queue</code> interface and orders elements based on their natural order or according to a specified comparator. It does not guarantee FIFO order, as elements are dequeued in priority order rather than the order of insertion.</p>
        <ul>
          <li><strong>Data Structure</strong>: Binary Heap (for priority ordering)</li>
          <li><strong>Does Not Allow Duplicates</strong>: No (duplicates are allowed)</li>
          <li><strong>Preserves Insertion Order</strong>: No (elements are ordered by priority)</li>
          <li><strong>Null Insertion</strong>: No</li>
          <li><strong>Best For</strong>: When elements need to be processed based on priority rather than insertion order.</li>
        </ul>
  
        <h4>Example: PriorityQueue</h4>
        <pre><code>
  import java.util.PriorityQueue;
  
  public class PriorityQueueExample {
      public static void main(String[] args) {
          PriorityQueue<Integer> queue = new PriorityQueue<>();
          queue.add(10);
          queue.add(5);
          queue.add(20);
  
          // Displaying elements (will display in order of priority)
          while (!queue.isEmpty()) {
              System.out.println(queue.poll());
          }
      }
  }
        </code></pre>
  
        <h3>3. LinkedList</h3>
        <p>The <strong>LinkedList</strong> class implements the <code>Queue</code> interface as well, and it provides a doubly linked list-based implementation. It maintains the FIFO order for processing elements and allows for both efficient insertion and removal from both ends.</p>
        <ul>
          <li><strong>Data Structure</strong>: Doubly Linked List</li>
          <li><strong>Allows Duplicates</strong>: Yes</li>
          <li><strong>Preserves Insertion Order</strong>: Yes</li>
          <li><strong>Null Insertion</strong>: Yes</li>
          <li><strong>Best For</strong>: When elements need to be processed in the order they were added, with efficient removal and insertion from both ends of the queue.</li>
        </ul>
  
        <h4>Example: LinkedList as Queue</h4>
        <pre><code>
  import java.util.LinkedList;
  import java.util.Queue;
  
  public class LinkedListQueueExample {
      public static void main(String[] args) {
          Queue<String> queue = new LinkedList<>();
          queue.offer("Apple");
          queue.offer("Banana");
          queue.offer("Cherry");
  
          // Displaying elements (FIFO order)
          while (!queue.isEmpty()) {
              System.out.println(queue.poll());
          }
      }
  }
        </code></pre>
  
        <h3>Differences Between Queue Implementations</h3>
        <h4>Difference Between PriorityQueue and LinkedList</h4>
        <table border="1">
          <tr>
            <th>Aspect</th>
            <th>PriorityQueue</th>
            <th>LinkedList</th>
          </tr>
          <tr>
            <td>Data Structure</td>
            <td>Binary Heap (Priority-based ordering)</td>
            <td>Doubly Linked List (FIFO order)</td>
          </tr>
          <tr>
            <td>Preserves Insertion Order</td>
            <td>No (ordered by priority)</td>
            <td>Yes (FIFO order)</td>
          </tr>
          <tr>
            <td>Null Insertion</td>
            <td>No</td>
            <td>Yes</td>
          </tr>
          <tr>
            <td>Element Removal</td>
            <td>Based on priority</td>
            <td>FIFO order (from the head)</td>
          </tr>
          <tr>
            <td>Best For</td>
            <td>Priority-based processing</td>
            <td>FIFO processing, efficient insertion and removal from both ends</td>
          </tr>
        </table>
  
      </section>
  
      
    <section>
        <h2>Map Implementations in Java</h2>
        <p>The <code>Map</code> interface in Java represents a collection of key-value pairs, where each key is unique. Unlike other collections like <code>List</code> or <code>Set</code>, a <code>Map</code> allows the storage of data in the form of key-value associations. Below are some key implementations of the <code>Map</code> interface in Java:</p>
  
        <h3>1. Map</h3>
        <p>The <strong>Map</strong> interface represents a collection of key-value pairs where each key maps to exactly one value. It allows fast lookups, updates, and deletions of key-value pairs. While duplicate keys are not allowed, duplicate values are permitted.</p>
        <ul>
          <li><strong>Data Structure:</strong> Varies by implementation (e.g., hash table, tree, etc.)</li>
          <li><strong>Allows Duplicates:</strong> No (for keys)</li>
          <li><strong>Preserves Insertion Order:</strong> Depends on the implementation</li>
          <li><strong>Null Insertion:</strong> Yes (depends on the implementation)</li>
          <li><strong>Best For:</strong> Storing key-value pairs with fast retrieval based on keys.</li>
        </ul>
  
        <h3>2. HashMap</h3>
        <p>The <strong>HashMap</strong> class implements the <code>Map</code> interface using a hash table. It provides constant-time performance for most operations (insertion, deletion, retrieval) assuming the hash function distributes the elements properly.</p>
        <ul>
          <li><strong>Data Structure:</strong> Hash Table</li>
          <li><strong>Does Not Allow Duplicate Keys:</strong> Yes, but values can be duplicated</li>
          <li><strong>Preserves Insertion Order:</strong> No</li>
          <li><strong>Null Insertion:</strong> Yes (allows one null key and multiple null values)</li>
          <li><strong>Supports Heterogeneous Data:</strong> Yes (for both keys and values)</li>
        </ul>
  
        <h4>Example: HashMap</h4>
        <pre><code>
  import java.util.HashMap;
  
  public class HashMapExample {
      public static void main(String[] args) {
          HashMap<Integer, String> map = new HashMap<>();
          map.put(1, "Apple");
          map.put(2, "Banana");
          map.put(3, "Cherry");
  
          // Displaying key-value pairs
          map.forEach((key, value) -> System.out.println(key + ": " + value));
      }
  }
        </code></pre>
  
        <h3>3. LinkedHashMap</h3>
        <p>The <strong>LinkedHashMap</strong> class extends <code>HashMap</code> and maintains the insertion order of key-value pairs. It uses a doubly linked list to maintain the order in which elements were inserted, while still providing the fast lookup performance of a hash table.</p>
        <ul>
          <li><strong>Data Structure:</strong> Hash Table + Doubly Linked List</li>
          <li><strong>Does Not Allow Duplicate Keys:</strong> Yes, but values can be duplicated</li>
          <li><strong>Preserves Insertion Order:</strong> Yes</li>
          <li><strong>Null Insertion:</strong> Yes (allows one null key and multiple null values)</li>
          <li><strong>Supports Heterogeneous Data:</strong> Yes (for both keys and values)</li>
        </ul>
  
        <h4>Example: LinkedHashMap</h4>
        <pre><code>
  import java.util.LinkedHashMap;
  
  public class LinkedHashMapExample {
      public static void main(String[] args) {
          LinkedHashMap<Integer, String> map = new LinkedHashMap<>();
          map.put(1, "Apple");
          map.put(2, "Banana");
          map.put(3, "Cherry");
  
          // Displaying key-value pairs (insertion order is preserved)
          map.forEach((key, value) -> System.out.println(key + ": " + value));
      }
  }
        </code></pre>
  
        <h3>4. TreeMap</h3>
        <p>The <strong>TreeMap</strong> class implements the <code>Map</code> interface using a Red-Black tree. It orders the key-value pairs based on the natural ordering of the keys, or a specified comparator, and does not allow duplicate keys. <code>TreeMap</code> does not allow null keys, and only supports homogeneous data for keys.</p>
        <ul>
          <li><strong>Data Structure:</strong> Red-Black Tree</li>
          <li><strong>Does Not Allow Duplicate Keys:</strong> Yes, but values can be duplicated</li>
          <li><strong>Preserves Insertion Order:</strong> No (ordered by key)</li>
          <li><strong>Null Insertion:</strong> No (keys cannot be null)</li>
          <li><strong>Supports Heterogeneous Data:</strong> No (supports only homogeneous data for keys)</li>
        </ul>
  
        <h4>Example: TreeMap</h4>
        <pre><code>
  import java.util.TreeMap;
  
  public class TreeMapExample {
      public static void main(String[] args) {
          TreeMap<Integer, String> map = new TreeMap<>();
          map.put(3, "Apple");
          map.put(1, "Banana");
          map.put(2, "Cherry");
  
          // Displaying key-value pairs (sorted by key)
          map.forEach((key, value) -> System.out.println(key + ": " + value));
      }
  }
        </code></pre>
  
        <h3>Differences Between Map Implementations</h3>
        <h4>Difference Between HashMap, LinkedHashMap, and TreeMap</h4>
        <table border="1">
            <tr>
              <th>Aspect</th>
              <th>HashMap</th>
              <th>LinkedHashMap</th>
              <th>TreeMap</th>
            </tr>
            <tr>
              <td>Data Structure</td>
              <td>Hash Table</td>
              <td>Hash Table + Doubly Linked List</td>
              <td>Red-Black Tree</td>
            </tr>
            <tr>
              <td>Preserves Insertion Order</td>
              <td>No</td>
              <td>Yes</td>
              <td>No (sorted by key)</td>
            </tr>
            <tr>
              <td>Null Insertion</td>
              <td>Yes (one null key, multiple null values)</td>
              <td>Yes (one null key, multiple null values)</td>
              <td>No (keys cannot be null)</td>
            </tr>
            <tr>
              <td>Sorting of Keys</td>
              <td>No sorting</td>
              <td>No sorting (preserves insertion order)</td>
              <td>Sorted by natural order or custom comparator</td>
            </tr>
            <tr>
              <td>Supports Heterogeneous Data</td>
              <td>Yes (for both keys and values)</td>
              <td>Yes (for both keys and values)</td>
              <td>No (supports only homogeneous data for keys)</td>
            </tr>
            <tr>
              <td>Best For</td>
              <td>Fast lookups and updates with no ordering guarantee</td>
              <td>Preserving insertion order with fast lookups</td>
              <td>Automatic sorting of keys (natural or custom)</td>
            </tr>
          </table>    
      </section>
  
      <section>
        <h2>Hash Tables, Dictionaries, and Properties in Java</h2>
        <p>In Java, hash-based data structures such as <code>HashTable</code>, <code>Dictionary</code>, and <code>Properties</code> are used to store key-value pairs efficiently. Here's a detailed explanation:</p>
  
        <h3>1. HashTable</h3>
        <p><code>HashTable</code> is a synchronized implementation of a hash table that maps keys to values.</p>
        <ul>
          <li>Allows null values but does not allow <code>null</code> keys.</li>
          <li>Thread-safe as it is synchronized.</li>
          <li>Extends the <code>Dictionary</code> class.</li>
        </ul>
        <h4>Example: Using HashTable</h4>
        <pre><code>
  import java.util.Hashtable;
  
  public class HashTableExample {
      public static void main(String[] args) {
          Hashtable<Integer, String> table = new Hashtable<>();
          table.put(1, "Apple");
          table.put(2, "Banana");
          table.put(3, "Cherry");
  
          System.out.println("HashTable: " + table);
          System.out.println("Value for key 2: " + table.get(2));
      }
  }
        </code></pre>
  
        <h3>2. Dictionary</h3>
        <p><code>Dictionary</code> is an abstract class that represents a key-value pair data structure. It is the parent class of <code>HashTable</code>.</p>
        <ul>
          <li>It is an older class and is rarely used directly.</li>
          <li>Provides methods like <code>put()</code>, <code>get()</code>, and <code>remove()</code>.</li>
        </ul>
        <h4>Example: Using Dictionary</h4>
        <pre><code>
  import java.util.Dictionary;
  import java.util.Hashtable;
  
  public class DictionaryExample {
      public static void main(String[] args) {
          Dictionary<Integer, String> dictionary = new Hashtable<>();
          dictionary.put(1, "Alice");
          dictionary.put(2, "Bob");
          dictionary.put(3, "Charlie");
  
          System.out.println("Dictionary: " + dictionary);
          System.out.println("Value for key 1: " + dictionary.get(1));
      }
  }
        </code></pre>
  
        <h3>3. Properties</h3>
        <p><code>Properties</code> is a subclass of <code>Hashtable</code> that is used to maintain a list of key-value pairs, where both the key and the value are strings. It is often used for configuration purposes.</p>
        <ul>
          <li>Supports reading and writing to files using <code>load()</code> and <code>store()</code> methods.</li>
          <li>Widely used for configuration files in Java applications.</li>
        </ul>
        <h4>Example: Using Properties</h4>
        <pre><code>
  import java.io.FileOutputStream;
  import java.io.IOException;
  import java.util.Properties;
  
  public class PropertiesExample {
      public static void main(String[] args) {
          Properties properties = new Properties();
          properties.setProperty("username", "admin");
          properties.setProperty("password", "12345");
  
          System.out.println("Properties: " + properties);
  
          try (FileOutputStream fos = new FileOutputStream("config.properties")) {
              properties.store(fos, "Configuration Settings");
              System.out.println("Properties saved to file.");
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
        </code></pre>
  
        <h4>Loading Properties from a File</h4>
        <pre><code>
  import java.io.FileInputStream;
  import java.io.IOException;
  import java.util.Properties;
  
  public class LoadPropertiesExample {
      public static void main(String[] args) {
          Properties properties = new Properties();
          try (FileInputStream fis = new FileInputStream("config.properties")) {
              properties.load(fis);
              System.out.println("Properties loaded: " + properties);
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
        </code></pre>
      </section>

      <section>
        <h2>Comparison: HashTable vs HashMap</h2>
        <p>Both <code>HashTable</code> and <code>HashMap</code> are implementations of the <code>Map</code> interface in Java, but they have significant differences. Here's a detailed comparison:</p>
  
        <table border="1" cellpadding="10" cellspacing="0" style="border-collapse: collapse; width: 100%; text-align: left;">
          <thead>
            <tr>
              <th>Aspect</th>
              <th>HashTable</th>
              <th>HashMap</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Synchronization</strong></td>
              <td>Thread-safe and synchronized. Multiple threads cannot access it simultaneously.</td>
              <td>Not synchronized. It is faster but requires external synchronization for thread safety.</td>
            </tr>
            <tr>
              <td><strong>Null Keys and Values</strong></td>
              <td>Does not allow <code>null</code> keys or <code>null</code> values.</td>
              <td>Allows one <code>null</code> key and multiple <code>null</code> values.</td>
            </tr>
            <tr>
              <td><strong>Performance</strong></td>
              <td>Slower due to synchronization overhead.</td>
              <td>Faster because it is not synchronized.</td>
            </tr>
            <tr>
              <td><strong>Legacy vs Modern</strong></td>
              <td>Part of the older <code>java.util</code> legacy classes.</td>
              <td>Introduced in Java 1.2 as part of the modern <code>java.util</code> collections framework.</td>
            </tr>
            <tr>
              <td><strong>Usage in Concurrent Environments</strong></td>
              <td>Suitable for multithreaded environments due to built-in synchronization.</td>
              <td>Requires explicit synchronization or use of <code>Collections.synchronizedMap()</code> for multithreaded environments.</td>
            </tr>
            <tr>
              <td><strong>Default Capacity</strong></td>
              <td>11 (resized by multiplying capacity by 2 and adding 1).</td>
              <td>16 (resized by doubling the capacity).</td>
            </tr>
          </tbody>
        </table>
</section>  

     
    </main>
  </main>

  <!-- Footer Placeholder -->
  <div id="footer-container"></div>
  <script src="../js/scripts.js"></script>
</body>
</html>
