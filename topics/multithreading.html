<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multithreading and Multiprocessing in Java</title>
  <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
  <!-- Placeholder for Header -->
  <div id="header-container"></div>

  <main>
    <!-- Section: Introduction -->
    <section>
      <h2>Multithreading and Multiprocessing in Java</h2>
      <p>Java supports concurrent programming through multithreading and multiprocessing. These mechanisms enable a program to perform multiple tasks simultaneously, improving performance and resource utilization.</p>
    </section>

    <!-- Section: What is Multiprocessing? -->
    <section>
      <h3>What is Multiprocessing?</h3>
      <p>Multiprocessing is the capability of a system to run multiple processes simultaneously. Each process runs independently, having its own memory space and resources.</p>
      <p><strong>Example:</strong> Running multiple Java applications on the same system.</p>
    </section>

    <!-- Section: What is Multithreading? -->
    <section>
      <h3>What is Multithreading?</h3>
      <p>Multithreading is a programming technique where a single process can execute multiple threads concurrently. Threads share the same memory space and resources.</p>
      <pre><code>
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running...");
    }
}

public class MultithreadingExample {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start(); // Start the thread
    }
}
      </code></pre>
    </section>

    <!-- Section: Differences -->
    <section>
      <h3>Differences Between Multiprocessing and Multithreading</h3>
      <table border="1" cellpadding="10">
        <thead>
          <tr>
            <th>Feature</th>
            <th>Multiprocessing</th>
            <th>Multithreading</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Memory</td>
            <td>Each process has its own memory space.</td>
            <td>Threads share the same memory space.</td>
          </tr>
          <tr>
            <td>Communication</td>
            <td>Processes communicate using IPC (Inter-Process Communication).</td>
            <td>Threads communicate more easily by sharing memory.</td>
          </tr>
          <tr>
            <td>Overhead</td>
            <td>Higher due to context switching between processes.</td>
            <td>Lower due to lightweight threads.</td>
          </tr>
          <tr>
            <td>Execution</td>
            <td>Independent processes run in parallel.</td>
            <td>Threads run within the same process.</td>
          </tr>
        </tbody>
      </table>
    </section>

    <!-- Section: Creating Threads -->
    <section>
      <h3>Creating Threads in Java</h3>
      <p>Threads can be created in Java using two main approaches:</p>
      <h4>1. Extending the Thread Class</h4>
      <pre><code>
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running...");
    }
}

public class ThreadExample {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start(); // Start the thread
    }
}
      </code></pre>

      <h4>2. Implementing the Runnable Interface</h4>
      <pre><code>
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread is running...");
    }
}

public class RunnableExample {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        t1.start(); // Start the thread
    }
}
      </code></pre>
    </section>
    <!-- Section: Getting and Setting Name of a Thread -->
    <section>
      <h2>Getting and Setting the Name of a Thread</h2>
      <p>In Java, every thread has a name, which can be set by the programmer or automatically generated by the JVM. The <code>Thread</code> class provides methods to get and set the name of a thread.</p>

      <h3>Methods to Get and Set Thread Name</h3>
      <ul>
        <li><strong><code>getName()</code>:</strong> Returns the current name of the thread.</li>
        <li><strong><code>setName(String name)</code>:</strong> Sets a new name for the thread. This can only be done before the thread starts.</li>
      </ul>

      <h4>Example:</h4>
      <pre><code>
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread is running.");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();  // Create a thread instance
        thread.setName("MyCustomThread");  // Set the thread's name
        thread.start();                    // Start the thread
        System.out.println("Thread name: " + thread.getName());  // Get the thread's name
    }
}
      </code></pre>
      <p>In this example, the thread's name is set before starting the thread, and the name is then retrieved and displayed.</p>
    </section>

    <!-- Section: Getting Current Executing Thread -->
    <section>
      <h2>Getting the Current Executing Thread</h2>
      <p>The <code>Thread.currentThread()</code> method returns a reference to the currently executing thread.</p>

      <h4>Example:</h4>
      <pre><code>
public class Main {
    public static void main(String[] args) {
        // Get the reference to the currently executing thread
        Thread currentThread = Thread.currentThread();
        
        // Display the name of the current thread
        System.out.println("Current thread name: " + currentThread.getName());
        
        // You can also set a new name for the current thread
        currentThread.setName("MainThread");
        
        // Display the new name of the current thread
        System.out.println("Updated thread name: " + currentThread.getName());
        
        // Example of starting a new thread using an anonymous inner class
        Thread newThread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("New thread is running.");
                System.out.println("New thread name: " + Thread.currentThread().getName());
            }
        });
        
        newThread.start();
    }
}
      </code></pre>
      <p>This example demonstrates how to get and set the name of the currently executing thread, and also how to start a new thread with an anonymous inner class.</p>
    </section>

    <!-- Section: Thread Priorities -->
    <section>
      <h2>Thread Priorities</h2>
      <p>Every thread in Java has a priority that determines the order in which threads are scheduled for execution. Thread priorities range from 1 (lowest) to 10 (highest), with the default priority being 5.</p>

      <h3>Standard Priority Constants</h3>
      <ul>
        <li><code>Thread.MIN_PRIORITY (1)</code>: The lowest thread priority.</li>
        <li><code>Thread.NORM_PRIORITY (5)</code>: The default thread priority.</li>
        <li><code>Thread.MAX_PRIORITY (10)</code>: The highest thread priority.</li>
      </ul>

      <h3>Getting and Setting Thread Priority</h3>
      <ul>
        <li><strong><code>getPriority()</code>:</strong> Returns the current priority of the thread.</li>
        <li><strong><code>setPriority(int newPriority)</code>:</strong> Sets the priority of the thread. The priority must be between 1 and 10, inclusive.</li>
      </ul>

      <h4>Error Handling for Invalid Priority</h4>
      <p>If an invalid priority (less than 1 or greater than 10) is set, the <code>IllegalArgumentException</code> will be thrown.</p>

      <h4>Example:</h4>
      <pre><code>
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " is running with priority " +
                Thread.currentThread().getPriority());
    }
}

public class Main {
    public static void main(String[] args) {
        // Create threads with different priorities
        Thread highPriorityThread = new Thread(new MyRunnable(), "HighPriorityThread");
        Thread mediumPriorityThread = new Thread(new MyRunnable(), "MediumPriorityThread");
        Thread lowPriorityThread = new Thread(new MyRunnable(), "LowPriorityThread");
        
        // Set priorities
        highPriorityThread.setPriority(Thread.MAX_PRIORITY); // Priority 10
        mediumPriorityThread.setPriority(Thread.NORM_PRIORITY); // Priority 5
        lowPriorityThread.setPriority(Thread.MIN_PRIORITY); // Priority 1
        
        // Start the threads
        lowPriorityThread.start();
        mediumPriorityThread.start();
        highPriorityThread.start();
    }
}
      </code></pre>
      <p>This example demonstrates how threads with different priorities are executed. The thread with the highest priority will be favored by the thread scheduler, although the exact execution order may vary depending on the platform.</p>
    </section>

    <!-- Section: Summary -->
    <section>
      <h2>Summary</h2>
      <table border="1" cellpadding="10">
        <thead>
          <tr>
            <th>Concept</th>
            <th>Method</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Thread Name</td>
            <td><code>setName(String name)</code> & <code>getName()</code></td>
            <td>Set and get the name of a thread.</td>
          </tr>
          <tr>
            <td>Current Thread</td>
            <td><code>currentThread()</code></td>
            <td>Get a reference to the currently executing thread.</td>
          </tr>
          <tr>
            <td>Thread Priority</td>
            <td><code>setPriority(int newPriority)</code> & <code>getPriority()</code></td>
            <td>Set and get the priority of a thread. Valid priorities range from 1 to 10.</td>
          </tr>
          <tr>
            <td>Invalid Priority</td>
            <td><code>IllegalArgumentException</code></td>
            <td>Thrown when an invalid priority value is set outside the range of 1 to 10.</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section>
      <h3>The Methods to Prevent a Thread from Execution:
        </h3>
      <p>We can prevent(stop) a Thread execution by using the following methods.
        1.	sleep();
        2.	join();
        3.	yield();</p>
      <h4>1. sleep() Method</h4>
      <p>The <code>sleep()</code> method pauses the current thread for a specified amount of time. If the thread is interrupted while sleeping, it throws an <code>InterruptedException</code>.</p>
      <pre><code>
class SleepExample extends Thread {
    public void run() {
        try {
            System.out.println("Thread sleeping for 2 seconds...");
            Thread.sleep(2000); // Sleep for 2 seconds
            System.out.println("Thread woke up!");
        } catch (InterruptedException e) {
            System.out.println("Thread was interrupted during sleep.");
        }
    }

    public static void main(String[] args) {
        SleepExample t1 = new SleepExample();
        t1.start();
    }
}
      </code></pre>

      <h4>2. join() Method</h4>
      <p>The <code>join()</code> method allows one thread to wait for another thread to finish its execution.</p>
      <pre><code>
class JoinExample extends Thread {
    public void run() {
        System.out.println(Thread.currentThread().getName() + " is running...");
    }

    public static void main(String[] args) throws InterruptedException {
        JoinExample t1 = new JoinExample();
        JoinExample t2 = new JoinExample();

        t1.start();
        t2.start();

        t1.join(); // Main thread waits for t1 to finish
        t2.join(); // Main thread waits for t2 to finish

        System.out.println("Both threads have finished.");
    }
}
      </code></pre>

      <h4>3. yield() Method</h4>
      <p>The <code>yield()</code> method is a suggestion to the thread scheduler that the current thread is willing to yield its CPU time slice. This method does not guarantee that other threads will execute immediately.</p>
      <pre><code>
class YieldExample extends Thread {
    public void run() {
        System.out.println(Thread.currentThread().getName() + " started.");
        Thread.yield(); // Yield to other threads
        System.out.println(Thread.currentThread().getName() + " resumed.");
    }

    public static void main(String[] args) {
        YieldExample t1 = new YieldExample();
        YieldExample t2 = new YieldExample();

        t1.start();
        t2.start();
    }
}
      </code></pre>

      <h4>Differences Between <code>sleep()</code>, <code>join()</code>, <code>yield()</code></h4>
      <table border="1" cellpadding="10">
        <thead>
          <tr>
            <th>Method</th>
            <th>Description</th>
            <th>Behavior</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>sleep()</code></td>
            <td>Pauses the current thread for a specified time.</td>
            <td>Thread is paused for the specified duration, can be interrupted.</td>
          </tr>
          <tr>
            <td><code>join()</code></td>
            <td>Allows the current thread to wait for another thread to complete.</td>
            <td>Blocks the current thread until the thread it is called on finishes executing.</td>
          </tr>
          <tr>
            <td><code>yield()</code></td>
            <td>Suggests the current thread yield control to other threads of the same priority.</td>
            <td>Thread gives up its CPU time slice, but no guarantee another thread will run.</td>
          </tr>
        </tbody>
      </table>
    </section>

    <!-- Section: Interrupting Threads -->
    <section>
      <h3>Interrupting Threads</h3>
      <p>Interrupting a thread allows you to stop its execution. The <code>interrupt()</code> method sets the interrupt flag for a thread, but the thread itself must periodically check this flag to handle the interruption appropriately.</p>
      <pre><code>
class InterruptExample extends Thread {
    public void run() {
        try {
            Thread.sleep(5000); // Sleep for 5 seconds
        } catch (InterruptedException e) {
            System.out.println("Thread was interrupted.");
        }
    }

    public static void main(String[] args) throws InterruptedException {
        InterruptExample t1 = new InterruptExample();
        t1.start();
        Thread.sleep(2000); // Wait for 2 seconds before interrupting
        t1.interrupt(); // Interrupt the thread
    }
}
      </code></pre>
      <p>In this example, the thread is interrupted after 2 seconds, and the interrupt flag is set, causing the thread to handle the interruption.</p>
    </section>

    <!-- Section: Thread Methods -->
    <section>
      <h3>Thread Methods</h3>
      <table border="1" cellpadding="10">
        <thead>
          <tr>
            <th>Method</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>start()</code></td>
            <td>Starts the thread and calls the <code>run()</code> method.</td>
          </tr>
          <tr>
            <td><code>run()</code></td>
            <td>Contains the code to be executed by the thread.</td>
          </tr>
          <tr>
            <td><code>sleep()</code></td>
            <td>Pauses the thread for a specified time.</td>
          </tr>
          <tr>
            <td><code>join()</code></td>
            <td>Waits for the thread to finish execution.</td>
          </tr>
          <tr>
            <td><code>isAlive()</code></td>
            <td>Checks if the thread is still running.</td>
          </tr>
        </tbody>
      </table>
    </section>

              <!-- Section: Thread States -->
              <section>
                <h3>Thread Life Cycle</h3>
                <p>Each thread in Java can be in one of several states:</p>
                <ul>
                  <li><strong>New:</strong> The thread is created but not started.</li>
                  <li><strong>Runnable:</strong> The thread is ready to run and is waiting for the CPU.</li>
                  <li><strong>Blocked:</strong> The thread is blocked while waiting for resources.</li>
                  <li><strong>Waiting:</strong> The thread is waiting indefinitely for another thread to perform a particular action.</li>
                  <li><strong>Timed Waiting:</strong> The thread is waiting for a specific amount of time.</li>
                  <li><strong>Terminated:</strong> The thread has finished executing.</li>
                </ul>
          
                <h4>Example of Thread State Transitions:</h4>
                <pre><code>
          class ThreadStateExample extends Thread {
              public void run() {
                  System.out.println("Thread is running...");
              }
          
              public static void main(String[] args) throws InterruptedException {
                  ThreadStateExample t1 = new ThreadStateExample();
          
                  System.out.println("State after creation: " + t1.getState()); // NEW
                  t1.start();
                  System.out.println("State after calling start(): " + t1.getState()); // RUNNABLE
                  t1.join();
                  System.out.println("State after thread termination: " + t1.getState()); // TERMINATED
              }
          }
                </code></pre>
              </section>
    <!-- Section: Daemon Threads -->
    <section>
      <h3>Daemon Threads</h3>
      <p>Daemon threads run in the background to perform tasks like garbage collection. Use the <code>setDaemon()</code> method to mark a thread as a daemon.</p>
      <pre><code>
class MyDaemonThread extends Thread {
    public void run() {
        System.out.println("Daemon thread running...");
    }
}

public class DaemonExample {
    public static void main(String[] args) {
        MyDaemonThread t1 = new MyDaemonThread();
        t1.setDaemon(true); // Set as daemon thread
        t1.start();
    }
}
      </code></pre>
    </section>

    <!-- Section: Synchronization -->
    <section>
      <h2>Synchronization in Java</h2>
      <p>Synchronization in Java is a mechanism that ensures only one thread can access a critical section of code at a time, preventing concurrent access issues and avoiding data inconsistency. This mechanism is essential when multiple threads access shared resources.</p>

      <h3>How Synchronization Works</h3>
      <p>When a thread enters a synchronized method or block, it acquires a lock on the object (or class, in the case of static synchronization), ensuring that only one thread can execute the synchronized code at a time while all other threads are in a waiting state.</p>
      <ul>
        <li><strong>Synchronized methods:</strong> A method is synchronized by adding the <code>synchronized</code> keyword to its declaration.</li>
        <li><strong>Synchronized blocks:</strong> A block of code can be synchronized by wrapping it with a <code>synchronized</code> block.</li>
      </ul>

      <h3>Advantages and Disadvantages of Synchronization</h3>
      <h4>Advantages:</h4>
      <ul>
        <li>Ensures data consistency by preventing multiple threads from modifying shared resources simultaneously.</li>
        <li>Helps avoid issues like race conditions and deadlocks, ensuring thread safety.</li>
      </ul>

      <h4>Disadvantages:</h4>
      <ul>
        <li>Increases waiting time for threads as other threads must wait for the lock to be released.</li>
        <li>Can lead to decreased performance if synchronization is not used judiciously.</li>
      </ul>

      <h3>Example: Synchronizing Methods</h3>
      <p>The <code>synchronized</code> keyword can be applied to methods to ensure that only one thread can execute the method at a time.</p>
      <pre><code>
class Counter {
    private int count = 0;

    // Synchronized method to ensure thread-safe increment
    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class SynchronizationExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        // Create two threads that will increment the counter
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        // Start the threads
        t1.start();
        t2.start();

        // Wait for both threads to finish
        t1.join();
        t2.join();

        // Print the final count after both threads have completed
        System.out.println("Final count: " + counter.getCount());
    }
}
      </code></pre>
      <p>In this example, the <code>increment()</code> method is synchronized, ensuring that only one thread can increment the count at a time.</p>

      <h3>Example: Synchronizing Blocks</h3>
      <p>Instead of synchronizing an entire method, you can synchronize specific blocks of code within a method. This is often used for fine-grained control over which sections of code need synchronization.</p>
      <pre><code>
class Counter {
    private int count = 0;

    public void increment() {
        // Synchronizing only the critical section
        synchronized(this) {
            count++;
        }
    }

    public int getCount() {
        return count;
    }
}

public class SynchronizationExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        // Create two threads that will increment the counter
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        // Start the threads
        t1.start();
        t2.start();

        // Wait for both threads to finish
        t1.join();
        t2.join();

        // Print the final count after both threads have completed
        System.out.println("Final count: " + counter.getCount());
    }
}
      </code></pre>
      <p>This example demonstrates how to use a synchronized block to protect only the critical section of code where shared resources are accessed, providing more control over synchronization.</p>

      <h3>Static Synchronization</h3>
      <p>Static synchronization is used when a thread needs to lock the class itself (not just the instance). This is done by synchronizing static methods.</p>
      <pre><code>
class Counter {
    private static int count = 0;

    // Synchronized static method
    public static synchronized void increment() {
        count++;
    }

    public static int getCount() {
        return count;
    }
}

public class SynchronizationExample {
    public static void main(String[] args) throws InterruptedException {
        // Create two threads that will increment the counter
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                Counter.increment();
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                Counter.increment();
            }
        });

        // Start the threads
        t1.start();
        t2.start();

        // Wait for both threads to finish
        t1.join();
        t2.join();

        // Print the final count after both threads have completed
        System.out.println("Final count: " + Counter.getCount());
    }
}
      </code></pre>
      <p>In this example, the static <code>increment()</code> method is synchronized, which ensures that only one thread can access this method at a time across all instances of the class.</p>
    </section>

    <section>
      <h3>Inter-Thread Communication</h3>
      <p>Inter-thread communication allows threads to communicate using the <code>wait()</code>, <code>notify()</code>, and <code>notifyAll()</code> methods. These methods allow threads to cooperate and coordinate their execution, especially when one thread needs to wait for a condition to be met by another thread.</p>
      <p>The classic example of inter-thread communication is the producer-consumer problem, where one thread produces items and another consumes them. The consumer thread waits until the producer thread produces an item.</p>

      <h4>Producer-Consumer Example</h4>
      <pre><code>
class SharedResource {
private boolean available = false;

public synchronized void produce() throws InterruptedException {
  while (available) {
      wait(); // Wait until the item is consumed
  }
  System.out.println("Produced");
  available = true; // Item is now produced
  notify(); // Notify the consumer that the item is produced
}

public synchronized void consume() throws InterruptedException {
  while (!available) {
      wait(); // Wait until the item is produced
  }
  System.out.println("Consumed");
  available = false; // Item is now consumed
  notify(); // Notify the producer that the item is consumed
}
}

public class InterThreadExample {
public static void main(String[] args) {
  SharedResource resource = new SharedResource();

  Thread producer = new Thread(() -> {
      try {
          for (int i = 0; i < 5; i++) {
              resource.produce();
          }
      } catch (InterruptedException e) {
          e.printStackTrace();
      }
  });

  Thread consumer = new Thread(() -> {
      try {
          for (int i = 0; i < 5; i++) {
              resource.consume();
          }
      } catch (InterruptedException e) {
          e.printStackTrace();
      }
  });

  producer.start();
  consumer.start();
}
}
      </code></pre>
      <p>In this example, the producer thread produces an item and notifies the consumer thread, which consumes the item. The consumer thread waits if the item is not available. The producer and consumer threads synchronize their work using the <code>wait()</code> and <code>notify()</code> methods.</p>

      <h4>How It Works:</h4>
      <ul>
          <li>The producer thread produces an item and sets the <code>available</code> flag to <code>true</code>.</li>
          <li>If the consumer thread finds the <code>available</code> flag is <code>false</code>, it calls <code>wait()</code> to wait until the item is available.</li>
          <li>The producer, after producing the item, calls <code>notify()</code> to signal the consumer thread that the item is now available.</li>
          <li>Similarly, the consumer thread, after consuming the item, calls <code>notify()</code> to signal the producer thread that the item is consumed.</li>
      </ul>
      <p>This mechanism helps ensure that the producer and consumer threads work in sync, without one thread running ahead or being blocked unnecessarily.</p>
  </section>


        <!-- Section: Thread Safety and Deadlock -->
        <section>
            <h3>Thread Safety and Deadlock</h3>
            <p>Thread safety refers to the ability of a program or a section of code to function correctly when multiple threads access it simultaneously. Deadlock occurs when two or more threads are blocked forever due to mutual resource locking.</p>
      
            <h4>Thread Safety Example:</h4>
            <p>Use synchronization to prevent thread interference when multiple threads access shared resources simultaneously.</p>
            <pre><code>
      class SafeCounter {
          private int count = 0;
      
          public synchronized void increment() {
              count++;
          }
      
          public int getCount() {
              return count;
          }
      }
      
      public class ThreadSafetyExample {
          public static void main(String[] args) throws InterruptedException {
              SafeCounter counter = new SafeCounter();
      
              Thread t1 = new Thread(() -> {
                  for (int i = 0; i < 1000; i++) {
                      counter.increment();
                  }
              });
      
              Thread t2 = new Thread(() -> {
                  for (int i = 0; i < 1000; i++) {
                      counter.increment();
                  }
              });
      
              t1.start();
              t2.start();
      
              t1.join();
              t2.join();
      
              System.out.println("Final Count: " + counter.getCount()); // Ensure thread safety
          }
      }
            </code></pre>
      
            <h4>Deadlock Example:</h4>
            <p>Deadlock occurs when two or more threads are blocked forever due to circular resource dependency.</p>
            <pre><code>
      class Resource1 {
          public synchronized void method1(Resource2 resource2) {
              System.out.println("Thread 1: Holding Resource 1...");
              try { Thread.sleep(100); } catch (InterruptedException e) {}
              resource2.last();
          }
      
          public synchronized void last() {
              System.out.println("Thread 1: In method last");
          }
      }
      
      class Resource2 {
          public synchronized void method2(Resource1 resource1) {
              System.out.println("Thread 2: Holding Resource 2...");
              try { Thread.sleep(100); } catch (InterruptedException e) {}
              resource1.last();
          }
      
          public synchronized void last() {
              System.out.println("Thread 2: In method last");
          }
      }
      
      public class DeadlockExample {
          public static void main(String[] args) {
              final Resource1 resource1 = new Resource1();
              final Resource2 resource2 = new Resource2();
      
              Thread t1 = new Thread(() -> resource1.method1(resource2));
              Thread t2 = new Thread(() -> resource2.method2(resource1));
      
              t1.start();
              t2.start();
          }
      }
            </code></pre>
            <p>In this example, two threads hold resources that the other thread needs, resulting in a deadlock.</p>
          </section>
      
          <!-- Section: Thread Pool Executor -->
          <section>
            <h2>Thread Pool Executor</h2>
            <p>The <code>ExecutorService</code> interface provides methods to manage a pool of threads efficiently. The <code>ThreadPoolExecutor</code> class manages a pool of worker threads to execute tasks.</p>
            
              <h3>Types of Executors in Java</h3>
              <p>In Java, executors are part of the <code>java.util.concurrent</code> package, and they provide a high-level mechanism for managing and controlling threads. Executors manage a pool of worker threads and allow tasks to be executed asynchronously, improving the efficiency and responsiveness of multithreaded programs.</p>
        
              <h3>Executor Factory Methods</h3>
              <p>The <code>Executor</code> class offers factory methods to create thread pools for managing and executing tasks. The following are the most commonly used factory methods:</p>
        
              <ul>
                <li><strong><code>newFixedThreadPool(int n)</code></strong>: Creates a thread pool with a fixed number of threads. If all threads are busy, additional tasks are queued until a thread becomes available.</li>
                <li><strong><code>newCachedThreadPool()</code></strong>: Creates a thread pool that dynamically adjusts the number of threads based on demand. If a thread is idle for 60 seconds, it is removed from the pool.</li>
                <li><strong><code>newSingleThreadExecutor()</code></strong>: Creates a thread pool with a single worker thread that executes tasks sequentially. This is useful for tasks that must be executed in order.</li>
              </ul>
        
              <h3>How Executors Work</h3>
              <p>The basic workflow of how tasks are managed by executors is as follows:</p>
              <ol>
                <li>You submit a task to the executor using methods like <code>submit()</code> or <code>execute()</code>.</li>
                <li>The executor places the task in a task queue.</li>
                <li>A worker thread from the pool retrieves the task from the queue and executes it.</li>
                <li>Once the task is complete, the worker thread returns to the pool, ready to execute another task.</li>
              </ol>
        
              <h3>Benefits of Using Executors</h3>
              <ul>
                <li><strong>Improved Responsiveness:</strong> Executors allow tasks to be executed concurrently, improving overall system responsiveness and reducing task wait time.</li>
                <li><strong>Better Resource Utilization:</strong> Threads are reused, which reduces the overhead of creating and destroying threads, making the system more efficient.</li>
                <li><strong>Enhanced Scalability:</strong> Executors make it easy to scale the system up or down based on workload demands. You can add or remove threads dynamically as needed.</li>
              </ul>
        
              <h3>Examples of Executors</h3>
        
              <h4>1. Using newFixedThreadPool</h4>
              <p>The <code>newFixedThreadPool()</code> method creates a fixed-size thread pool.</p>
              <pre><code>
        import java.util.concurrent.ExecutorService;
        import java.util.concurrent.Executors;
        
        public class FixedThreadPoolExample {
            public static void main(String[] args) {
                ExecutorService executor = Executors.newFixedThreadPool(3);
        
                for (int i = 0; i < 5; i++) {
                    executor.submit(() -> {
                        System.out.println(Thread.currentThread().getName() + " is executing a task.");
                    });
                }
        
                executor.shutdown();
            }
        }
              </code></pre>
              <p>In this example, we create a thread pool with 3 threads. The first 3 tasks are executed immediately, and the remaining 2 tasks are queued until a thread becomes available.</p>
        
              <h4>2. Using newCachedThreadPool</h4>
              <p>The <code>newCachedThreadPool()</code> method creates a thread pool that dynamically adjusts the number of threads based on demand.</p>
              <pre><code>
        import java.util.concurrent.ExecutorService;
        import java.util.concurrent.Executors;
        
        public class CachedThreadPoolExample {
            public static void main(String[] args) {
                ExecutorService executor = Executors.newCachedThreadPool();
        
                for (int i = 0; i < 5; i++) {
                    executor.submit(() -> {
                        System.out.println(Thread.currentThread().getName() + " is executing a task.");
                    });
                }
        
                executor.shutdown();
            }
        }
              </code></pre>
              <p>In this example, threads are created as needed, and idle threads are removed after 60 seconds of inactivity.</p>
        
              <h4>3. Using newSingleThreadExecutor</h4>
              <p>The <code>newSingleThreadExecutor()</code> method creates a thread pool with a single worker thread that executes tasks sequentially.</p>
              <pre><code>
        import java.util.concurrent.ExecutorService;
        import java.util.concurrent.Executors;
        
        public class SingleThreadExecutorExample {
            public static void main(String[] args) {
                ExecutorService executor = Executors.newSingleThreadExecutor();
        
                for (int i = 0; i < 5; i++) {
                    executor.submit(() -> {
                        System.out.println(Thread.currentThread().getName() + " is executing a task.");
                    });
                }
        
                executor.shutdown();
            }
        }
              </code></pre>
              <p>In this example, even though multiple tasks are submitted, they are executed sequentially by the single worker thread in the pool.</p>
            </section>
      
          <!-- Section: Summary -->
          <section>
            <h3>Summary</h3>
            <table border="1" cellpadding="10">
              <thead>
                <tr>
                  <th>Concept</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Multithreading</td>
                  <td>Allows concurrent execution of multiple threads within the same process, sharing the same memory space.</td>
                </tr>
                <tr>
                  <td>Multiprocessing</td>
                  <td>Allows multiple processes to run simultaneously, each with its own memory space.</td>
                </tr>
                <tr>
                  <td>Thread Safety</td>
                  <td>Ensures that shared resources are properly managed when accessed by multiple threads.</td>
                </tr>
                <tr>
                  <td>Daemon Threads</td>
                  <td>Background threads that do not prevent the JVM from exiting.</td>
                </tr>
                <tr>
                  <td>Synchronization</td>
                  <td>Prevents thread interference when multiple threads access shared resources.</td>
                </tr>
                <tr>
                  <td>Inter-Thread Communication</td>
                  <td>Allows threads to communicate using <code>wait()</code>, <code>notify()</code>, and <code>notifyAll()</code>.</td>
                </tr>
                <tr>
                  <td>Thread Pool Executor</td>
                  <td>Manages a pool of worker threads to efficiently handle multiple tasks concurrently.</td>
                </tr>
              </tbody>
            </table>
          </section>
        </main>
        <script src="../js/scripts.js"></script>
        <footer>
          <p>&copy; 2024 Multithreading and Multiprocessing in Java Tutorial</p>
        </footer>
      </body>
      </html>
      
